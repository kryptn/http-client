{
package language

// helpers
func ifs(v interface{}) []interface{} {
	if v == nil {
		return nil
	}
	return v.([]interface{})
}

func dumps(origin string, values ...interface{}){
    // helps debug
    for _, value := range values {
        print("dumping from ", origin, ":\n\n")
        spew.Dump(value)
        print("\n\n")
    }
}

}

Document <- _ block:Block _ EOF {
    return block.(Block), nil
}

Block <- blockType:Word _ '{' _ items:(KeyValuePair / Block)* _ '}' {

    // print("\n\ndumping c\n")
    // spew.Dump(c)
    // print("\n\ndumping blockType\n")
    // spew.Dump(blockType)
    // print("\n\ndumping items\n")
    // spew.Dump(items)

    keyValuePairs := []KeyValuePair{}
    subBlocks := []Block{}

    for _, item := range ifs(items){
        switch v := item.(type) {
        case KeyValuePair:
            keyValuePairs = append(keyValuePairs, v)
        case Block:
            subBlocks = append(subBlocks, v)
        default:
            return nil, errors.New("expected Block or KeyValuePair") // todo: does this need more?
        }
    }

    return Block{
        BlockType: blockType.(string),
        KeyValuePairs: keyValuePairs,
        SubBlocks: subBlocks,
    }, nil
}

FunctionInvocation <- '{' _ fnCall:FunctionCall+ '}' {
    fns := []FunctionInvocation{}
    dumps("FunctionInvocation", c, fnCall)
    for _, fn := range ifs(fnCall){
        fns = append(fns, fn.(FunctionInvocation))
    }
    return fns, nil
}

FunctionCall <- fnName:Name argsi:Argument* _ ('|' _)? {
    dumps("FunctionCall", c, c.text, fnName, argsi)
    args := []Argument{}
    for _, arg := range ifs(argsi){
        args = append(args, arg.(Argument))

    }
    return FunctionInvocation{FuncName:fnName.(string), Arguments: args}, nil
}

Argument <- ' '+ v:ArgumentValue {
    return Argument{
        StrValue: v.(Value).StrValue,
        FuncValue: v.(Value).FuncValue,
    }, nil
}


KeyValuePair <- _ k:Key ':' _ v:Value+ _ {
    // dumps("KeyValuePair", c, k, v)
    values := []Value{}
    for _, value := range v.([]interface{}){
        values = append(values, value.(Value))
    }

    return KeyValuePair{Key:k.(Key), Values:values}, nil
}

Word <- [0-9a-z_-]i+ {
    return string(c.text), nil
}

Name <- [a-z]i [0-9a-z_-]i* {
    return string(c.text), nil
}

Words <- (Word / [ \t]+)+

Key <- w:Word {
    return Key(w.(string)), nil
}

// any number of words
Value <- fn:FunctionInvocation {
    dumps("Value FunctionInvocation", c, fn)
    return Value{FuncValue: fn.([]FunctionInvocation)}, nil
} / Words {
    dumps("Value Word", c)
    return Value{StrValue: string(c.text)}, nil
}

// assumes one word per argument
ArgumentValue <- fn:FunctionInvocation {
    dumps("ArgumentValue FunctionInvocation", c, fn)
    return Value{FuncValue: fn.([]FunctionInvocation)}, nil
} / Word {
    dumps("ArgumentValue Word", c)
    return Value{StrValue: string(c.text)}, nil
}

EOF <- !.

sp <- [ \t]* {
    return nil, nil
}

nl <- [\r\n]* {
    return nil, nil
}

_ "whitespace" <- [ \t\r\n]* {
    return nil, nil
}

