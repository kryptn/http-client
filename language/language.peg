{
package language

// helpers
func ifs(v interface{}) []interface{} {
	if v == nil {
		return nil
	}
	return v.([]interface{})
}

}

Document <- _ block:Block _ EOF {
    return block.(Block), nil
}

Block <- blockType:Word _ '{' _ items:(KeyValuePair / Block)* _ '}' {

    keyValuePairs := []KeyValuePair{}
    subBlocks := []Block{}

    for _, item := range ifs(items){
        switch v := item.(type) {
        case KeyValuePair:
            keyValuePairs = append(keyValuePairs, v)
        case Block:
            subBlocks = append(subBlocks, v)
        default:
            return nil, errors.New("expected Block or KeyValuePair") // todo: does this need more?
        }
    }

    return Block{
        BlockType: blockType.(string),
        KeyValuePairs: keyValuePairs,
        SubBlocks: subBlocks,
    }, nil
}

FunctionInvocation <- '{' _ fnCall:FunctionCall+ '}' {
    fns := []FunctionInvocation{}
    dumps("FunctionInvocation", c, fnCall)
    for _, fn := range ifs(fnCall){
        fns = append(fns, fn.(FunctionInvocation))
    }
    return fns, nil
}

FunctionCall <- fnName:Name argsi:Argument* _ ('|' _)? {
    dumps("FunctionCall", c, c.text, fnName, argsi)
    args := []Argument{}
    for _, arg := range ifs(argsi){
        args = append(args, arg.(Argument))

    }
    return FunctionInvocation{FuncName:fnName.(string), Arguments: args}, nil
}

Argument <- ' '+ v:ArgumentValue {
    return Argument{
        StrValue: v.(Value).StrValue,
        FuncValue: v.(Value).FuncValue,
    }, nil
}


KeyValuePair <- _ k:Key ':' _ v:Value+ _ {
    dumps("KeyValuePair", c, k, v)
    values := []Value{}
    for _, value := range v.([]interface{}){
        values = append(values, value.(Value))
    }

    return KeyValuePair{Key:k.(Key), Values:values}, nil
}

Word <- [0-9a-z_-]i+ {
    return string(c.text), nil
}

Name <- [a-z]i [0-9a-z_-]i* {
    return string(c.text), nil
}

Words <- (Word / [ \t]+)+

Key <- w:Word {
    dumps("Key", c, w)
    return Key(w.(string)), nil
}

// any number of words
Value <- fn:FunctionInvocation {
    dumps("Value FunctionInvocation", c, fn)
    return Value{FuncValue: fn.([]FunctionInvocation)}, nil
} / MultiLineValue / QuotedValue / Words {
    dumps("Value Word", c)
    return Value{StrValue: string(c.text)}, nil
}

QuotedValue <- "\"" contents:QuotedContents "\"" {
    return contents.(Value), nil
}

QuotedContents <- (. !'"')* . {
    return Value{StrValue: string(c.text)}, nil
}

MultiLineValue <- tplq contents:MultiLineContents tplq {
    dumps("MultiLineValue", c, contents)
    return contents.(Value), nil
}

MultiLineContents <- (. !tplq)* . {
    return Value{StrValue: string(c.text)}, nil
}

// assumes one word per argument
ArgumentValue <- fn:FunctionInvocation {
    dumps("ArgumentValue FunctionInvocation", c, fn)
    return Value{FuncValue: fn.([]FunctionInvocation)}, nil
} / Word {
    dumps("ArgumentValue Word", c)
    return Value{StrValue: string(c.text)}, nil
}

EOF <- !.

sp <- [ \t]* {
    return nil, nil
}

nl <- [\r\n]* {
    return nil, nil
}

tplq <- "\"\"\"" {
    dumps("tplq", c)
    return c, nil
}

_ "whitespace" <- [ \t\r\n]* {
    return nil, nil
}

